package function;

import java.util.ArrayList;
import java.util.HashMap;

import javax.swing.JPanel;

import com.starkeffect.highway.GPSDevice;

import elements.MapData;
import elements.Node;
import elements.NodeManager;
import elements.Way;
import gui.DisplayPanel;
import gui.GPSInfoPanel;

/**
 * Class keeps track of current node on the map, as well as a specified start and end node. 
 * The class implements GPSListener and will update to respond to changes prompted by the GPSDevice
 * that are generated by movement/change in currentNode, or setting of start and end locations.
 */
public class PositionTracker implements com.starkeffect.highway.GPSListener{

    private NodeManager nodeManager;
    private HashMap<String, ArrayList<Way>> nodeInWay;

    /** The display panel is a listener to PositionTracker */
    private DisplayPanel display;

    /** The information panel is a listener to PositionTracker */
    private GPSInfoPanel gpsInfo;

    /** The start node. May or may not be currentNode. */
    private Node startNode;

    /** 
     * The end node and/or destination.  
     */
    private Node endNode;

    /**
     * The closest node to the longitude and latitude
     * that is stored in current[] array;
     */
    private Node currentNode;

    /** 
     * The previous closest node; the closest node that was 
     * gotten from the previous GPSEvent. This is used to
     * check if we have moved enough s.t need to recompute.
     */
    private Node prevNode = null;

    /** The current position saved as an array of longitude
     * and latitude. Index position [0] is longitude, and
     * index position [1] is latitude.
     */
    private double[] current;

    /** 
     * Boolean indicating whether or not the car is
     * currently in driving. DriveMode indicates whether
     * or not [drive] was pressed on the GPSDevice.jar.
     * GPSEvents do not stop after starting.
     */
    private boolean driving = false;

    /** 
     * Whether or not reached or passed set endNode.
     * Finished is true if reached or passed endNode.
     */
    private boolean finished = false;

    /** 
     * The directions generator object to find a path
     * given a start to given end node.
     */
    private DirectionsGenerator directionsGenerator;

    /** The latest computed directions */
    private ArrayList<Node> directions; 


    // ------- end of fields ------- //

    /**
     * Constructor for NodeTracker class.
     * @param data The mapData object
     * @param The dataModel that generates events.
     */
    public PositionTracker( MapData data, GPSDevice device ){
	nodeManager = data.getNodeManager();
	nodeInWay = data.getWayManager().getnodeInWayMap();
	device.addGPSListener(this);

	current = new double[2];
	directions = new ArrayList<Node>();
	directionsGenerator = new DirectionsGenerator();
    }

    /**
     * Set a desired start node.
     * @param start Node to be specified as start.
     */
    public void setStartNode( Node start ){
	startNode = start;
    }

    /**
     * Get the start Node.
     * @return The start node.
     */
    public Node getStartNode(){
	return startNode;
    }

    /**
     * Set a desired end node (destination).
     * @param end Node to be destination/end.
     */
    public void setEndNode( Node end ){
	endNode = end;
	// new goals, never finished
	finished = false;
	directions = null;
    }

    /**
     * Get the end node.
     * @return The end node.
     */
    public Node getEndNode(){
	return endNode;
    }

    /** Set graphic display "listener" for this data */
    public void addGraphicListener(JPanel panel){
	this.display = (DisplayPanel) panel;
    }

    /** Set information "listener" for this data */
    public void addInfoListener(JPanel panel){
	gpsInfo = (GPSInfoPanel) panel;
    }

    /** 
     * Clear everything that we can.
     * note: We can't clear the car. 
     */
    public void clear(){
	startNode = null;
	endNode = null;
	directions = null;
    }

    /** Get the list of directions as Node list */
    public ArrayList<Node> getDirections(){
	if(startNode == null && currentNode == null) return null;
	if(endNode == null) return null; 

	if( startNode == null && currentNode != null){
	    startNode = currentNode;
	}

	if( !display.isListening() || directions == null || recalculate() ){
	    return directionsGenerator.generateDirections(startNode, endNode);
	} else {
	    return directions;
	}
    }

    /** Reset the directions */
    public void resetDirections(){
	directions = null;
    }

    /**
     * Get the current position of car in terms of
     * longitude and latitude. Index position at [0] 
     * is longitude, and index position [1] is latitude.
     * @return array where [0]=longitude, [1]=latitude.
     */
    public double[] getCurrentPosition(){
	return current;
    }

    /**
     * This method checks if driving is enabled.
     * Meaning that there is satellite reception.
     * @return true if driving enabled.
     */
    public boolean isDriving(){
	return driving;
    }

    /**
     * This method checks if the endNode was reached,
     * or reached and passed at some point.
     * @return true if at some point passed the endNode.
     */
    public boolean isFinished(){
	return finished;
    }

    /** Check if reached endNode. */
    private boolean thereYet(Node n){
	boolean reached = n.equals(endNode);

	// finished is set once when reached is true. 
	// If car moves beyond endNode, reached 
	// remains true until endNode is reset.
	if(reached) finished = true; 
	return reached;
    }

    /** Determine if the path should be recomputed. */
    private boolean recalculate(){
	return  prevNode == null || !prevNode.equals(currentNode) ;
    }

    /**
     * Follow the car; update position and check if there is need
     * to recompute the directions path. 
     */
    private void followCar(){

	double clon = current[0];
	double clat = current[1];
	display.drawCar(clon, clat);
	thereYet(currentNode);

	if( display.isListening() && !finished ){ // if we want to receive satellite signal
	    driving = true;
	    if( recalculate() ){
		directions = directionsGenerator.generateDirections(currentNode, endNode);
	    } 
	    startNode = currentNode;
	    display.setDriveMode(true);
	    display.setGPSPath(directions);

	} else {
	    display.setDriveMode(false);

	}
	gpsInfo.update(positionInfo());
    }

    /**
     * Obtain information on the car's current position, 
     * whether driving is enabled, and the endNode/destination. 
     * If driving is false, then returns the start node.
     */
    public String positionInfo(){
	String s = "";

	Way w = nodeInWay.get(currentNode.getID()).get(0);
	String name = w.getName();
	if( name == null ) name = w.getID();
	s+= "\nNear route: " + name + "."; // nearest route/way

	// destination exists
	if(endNode != null) s+= "\nReached Destination: " + finished + "\n";

	if( driving ){ 
	    String lon = String.format("%.8g", current[0]);
	    String lat = String.format("%.8g", current[1]);
	    s+= "\nCurrent Position: Longitude; " + lon + " Latitude: " + lat;

	} else if( startNode != null ) {
	    s+= "\n" + startNode.toString();
	}

	if(endNode!= null){
	    s+= "\nTo " + endNode.toString();

	    double dist0 = endNode.distFrom(current[0], current[1]);
	    String dist1 = String.format("%.5g", dist0);
	    s+= "\nDistance: " + dist1 + " miles from destination."; // distance from endNode
	}
	return s;
    }

    /**
     * Process the GPSEvent arg0.
     * @param arg0 The received event.
     */
    @Override
    public void processEvent(com.starkeffect.highway.GPSEvent arg0) {
	driving = true;

	double lon = arg0.getLongitude();
	double lat = arg0.getLatitude();
	current[0] = lon;
	current[1] = lat;

	Node n = nodeManager.closestNode(lon, lat);
	prevNode = currentNode; // save
	currentNode = n;
	followCar();
    }


}
